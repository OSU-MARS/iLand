using iLand.Input.ProjectFile;
using iLand.Tree;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;

namespace iLand.Input
{
    /// <summary>
    /// Resource unit climates and soil properties plus a few other settings.
    /// </summary>
    /// <remarks>
    /// Data is read from various sources and presented to the core model with a standardized interface.
    //  See http://iland-model.org/simulation+extent.
    /// </remarks>
    public class EnvironmentReader
    {
        private readonly Dictionary<string, int> environmentIndexByCoordinate;
        private readonly List<Environment> environments;

        public Dictionary<string, World.Climate> ClimatesByID { get; private init; }
        public World.Climate? CurrentClimate { get; private set; }
        public Environment? CurrentEnvironment { get; private set; }
        public int CurrentResourceUnitID { get; private set; } // current grid id (in grid mode the id of the stand grid, in matrix mode simply the an autogenerated index)
        public TreeSpeciesSet? CurrentSpeciesSet { get; private set; } // get species set on current pos

        // soil parameters not currently supported in environment file
        public float AnnualNitrogenDeposition { get; private set; }
        public float SoilQb { get; private set; }
        public bool UseDynamicAvailableNitrogen { get; private set; } // if true, iLand utilizes the soil-model N for species responses (and the dynamically calculated N available?)

        public Dictionary<string, TreeSpeciesSet> SpeciesSetsByTableName { get; private init; } // created species sets

        public EnvironmentReader()
        {
            this.environmentIndexByCoordinate = new Dictionary<string, int>();
            this.environments = new();

            this.ClimatesByID = new Dictionary<string, World.Climate>();
            this.CurrentClimate = null;
            this.CurrentEnvironment = null;
            this.CurrentResourceUnitID = 0;
            this.CurrentSpeciesSet = null;
            this.SpeciesSetsByTableName = new Dictionary<string, TreeSpeciesSet>();
        }

        public void LoadFromProjectAndEnvironmentFile(Project projectFile)
        {
            string environmentFilePath = projectFile.GetFilePath(ProjectDirectory.Home, projectFile.World.EnvironmentFile); // TODO: stop requiring gis\ prefix in project file
            using CsvFile resourceUnitEnvironmentFile = new(environmentFilePath);
            
            EnvironmentHeader environmentHeader = new(resourceUnitEnvironmentFile);

            Environment defaultEnvironment = new(projectFile.World);
            if (String.IsNullOrEmpty(defaultEnvironment.ClimateID) && (environmentHeader.ClimateID < 0))
            {
                throw new NotSupportedException("Environment file must have a '" + Constant.Setting.Climate.Name + "' column if '" + Constant.Setting.Climate.Name + "' is not specified in the project file.");
            }
            if (String.IsNullOrEmpty(defaultEnvironment.SpeciesTableName) && (environmentHeader.SpeciesTableName < 0))
            {
                throw new NotSupportedException("Environment file must have a '" + Constant.Setting.SpeciesTable + "' column if '" + Constant.Setting.SpeciesTable + "' is not specified in the project file.");
            }

            this.ClimatesByID.Clear();
            this.environmentIndexByCoordinate.Clear();
            this.environments.Clear();
            this.CurrentResourceUnitID = 0;
            this.SpeciesSetsByTableName.Clear();

            HashSet<string> uniqueSpeciesTableNames = new();
            resourceUnitEnvironmentFile.Parse((string[] row) =>
            {
                Environment resourceUnitEnvironment = new(environmentHeader, row, defaultEnvironment);

                environmentIndexByCoordinate[resourceUnitEnvironment.GetCentroidKey()] = this.environments.Count;
                this.environments.Add(resourceUnitEnvironment);

                if (this.ClimatesByID.TryGetValue(resourceUnitEnvironment.ClimateID, out World.Climate? climate) == false)
                {
                    // create only those climate sets that are really used in the current landscape
                    climate = new World.Climate(projectFile, resourceUnitEnvironment.ClimateID);
                    this.ClimatesByID.Add(resourceUnitEnvironment.ClimateID, climate);
                }

                if (uniqueSpeciesTableNames.Contains(resourceUnitEnvironment.SpeciesTableName) == false)
                {
                    uniqueSpeciesTableNames.Add(resourceUnitEnvironment.SpeciesTableName);
                }
            });

            if (this.environments.Count < 1)
            {
                throw new NotSupportedException("Resource unit environment file '" + environmentFilePath + "' is empty or has only headers.");
            }
            if (uniqueSpeciesTableNames.Count < 1)
            {
                throw new NotSupportedException("No species table was found in resource unit environment file '" + environmentFilePath + "' or in the project file.");
            }

            // create species sets
            foreach (string tableName in uniqueSpeciesTableNames)
            {
                TreeSpeciesSet speciesSet = new(tableName);
                speciesSet.Setup(projectFile);
                this.SpeciesSetsByTableName.Add(tableName, speciesSet);
            }

            // climates
            if (resourceUnitEnvironmentFile.GetColumnIndex(Constant.Setting.Climate.Name) == -1)
            {
                // no named climates defined: create a single default climate
                string defaultClimateName = "default";
                World.Climate defaultClimate = new(projectFile, defaultClimateName);
                this.ClimatesByID.Add(defaultClimateName, defaultClimate);
                this.CurrentClimate = defaultClimate;
            }
            // otherwise, instantiate named climates as needed
        }

        /// <summary>
        /// Moves environment enumerator to specified resource unit.
        /// </summary>
        public void MoveTo(PointF ruCentroid)
        {
            string key = (int)ruCentroid.X + "_" + (int)ruCentroid.Y;
            if (environmentIndexByCoordinate.TryGetValue(key, out int environmentIndex) == false)
            {
                throw new FileLoadException("Resource unit not found at (" + (int)ruCentroid.X + ", " + (int)ruCentroid.Y + ") in environment file.");
            }

            this.CurrentEnvironment = this.environments[environmentIndex];

            this.CurrentClimate = this.ClimatesByID[this.CurrentEnvironment.ClimateID];
            this.CurrentResourceUnitID = this.CurrentEnvironment.ResourceUnitID;
            this.CurrentSpeciesSet = this.SpeciesSetsByTableName[this.CurrentEnvironment.SpeciesTableName];
        }
    }
}
